# Complete Guide to Functional Programming in Python

## Table of Contents
1. [Introduction to Functional Programming](#introduction-to-functional-programming)
2. [Lambda Functions](#lambda-functions)
3. [Higher Order Functions](#higher-order-functions)
4. [Built-in Functional Tools](#built-in-functional-tools)
5. [Advanced Concepts](#advanced-concepts)
6. [Decorators](#decorators)
7. [Function Arguments (*args, **kwargs)](#function-arguments-args-kwargs)
8. [Practical Examples](#practical-examples)
9. [Best Practices](#best-practices)
10. [Exercises](#exercises)

---

## Introduction to Functional Programming

### What is Functional Programming? (Simple Explanation)

**Functional Programming** is a programming paradigm where you write code by composing functions, just like in mathematics.

**Think of it like cooking**:
- **Imperative style**: "Take eggs, crack them, beat them, add salt, cook in pan"
- **Functional style**: "Combine(beat(crack(eggs)), salt) → cook"

**Key Principles**:
1. **Functions are first-class citizens** - you can pass them around like variables
2. **Pure functions** - same input always gives same output, no side effects
3. **Immutability** - don't change data, create new data instead
4. **Composition** - build complex functions from simple ones

### Why Learn Functional Programming?

**Benefits**:
- **Easier to test** - pure functions are predictable
- **Easier to debug** - no hidden side effects
- **More readable** - code expresses what you want, not how to do it
- **Parallel processing** - pure functions can run safely in parallel

**Real-world analogy**:
- **Imperative**: Like giving step-by-step driving directions
- **Functional**: Like describing the destination and letting GPS figure out the route

---

## Lambda Functions

### What are Lambda Functions? (Simple Explanation)

**Lambda functions** are small, anonymous functions that you can create on the fly.

**Think of them like shortcuts**:
- Instead of writing a full function definition, you write a quick one-liner
- Like having a "quick note" vs. writing a full letter

### Basic Syntax

```python
# Regular function
def add(x, y):
    return x + y

# Lambda function (same thing, but shorter)
add_lambda = lambda x, y: x + y

# Both do the same thing
print(add(5, 3))        # Output: 8
print(add_lambda(5, 3)) # Output: 8
```

### Lambda Function Structure

```python
lambda arguments: expression
#     ↑           ↑
#   input      what to return
```

### Common Lambda Examples

```python
# 1. Simple math operations
square = lambda x: x ** 2
print(square(5))  # Output: 25

# 2. String operations
greet = lambda name: f"Hello, {name}!"
print(greet("Alice"))  # Output: Hello, Alice!

# 3. Multiple arguments
multiply = lambda x, y, z: x * y * z
print(multiply(2, 3, 4))  # Output: 24

# 4. Conditional expressions
is_even = lambda x: True if x % 2 == 0 else False
print(is_even(4))  # Output: True
print(is_even(5))  # Output: False

# 5. Working with lists
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x ** 2, numbers))
print(squared)  # Output: [1, 4, 9, 16, 25]
```

### When to Use Lambda Functions

**Good uses**:
- **Short, simple operations** (one-liners)
- **As arguments to other functions** (map, filter, etc.)
- **Quick transformations**

**Avoid when**:
- **Complex logic** (use regular functions instead)
- **Multiple lines** (lambda should be simple)
- **Need to reuse** (create a named function)

### Lambda vs Regular Functions

```python
# Regular function - good for complex logic
def process_user_data(user):
    if user is None:
        return "No user"
    
    if user.get('age', 0) < 18:
        return f"Minor: {user['name']}"
    else:
        return f"Adult: {user['name']}"

# Lambda - good for simple operations
get_name = lambda user: user.get('name', 'Unknown')
```

---

## Higher Order Functions

### What are Higher Order Functions? (Simple Explanation)

**Higher Order Functions** are functions that either:
1. **Take other functions as arguments**
2. **Return functions as results**

**Real-world analogy**:
- Like a **recipe that takes other recipes as ingredients**
- Or a **factory that produces other factories**

### Functions as Arguments

```python
# Function that takes another function as argument
def apply_operation(numbers, operation):
    """Apply an operation to each number in the list"""
    return [operation(num) for num in numbers]

# Different operations
def square(x):
    return x ** 2

def cube(x):
    return x ** 3

def double(x):
    return x * 2

# Using the higher order function
numbers = [1, 2, 3, 4, 5]

squared_numbers = apply_operation(numbers, square)
print(squared_numbers)  # Output: [1, 4, 9, 16, 25]

cubed_numbers = apply_operation(numbers, cube)
print(cubed_numbers)    # Output: [1, 8, 27, 64, 125]

doubled_numbers = apply_operation(numbers, double)
print(doubled_numbers)  # Output: [2, 4, 6, 8, 10]

# Using lambda functions
tripled_numbers = apply_operation(numbers, lambda x: x * 3)
print(tripled_numbers)  # Output: [3, 6, 9, 12, 15]
```

### Functions as Return Values

```python
# Function that returns another function
def create_multiplier(factor):
    """Create a function that multiplies by the given factor"""
    def multiplier(x):
        return x * factor
    return multiplier

# Create different multiplier functions
double = create_multiplier(2)
triple = create_multiplier(3)
quadruple = create_multiplier(4)

# Use the returned functions
print(double(5))    # Output: 10
print(triple(5))    # Output: 15
print(quadruple(5)) # Output: 20

# More complex example
def create_validator(min_length):
    """Create a function that validates string length"""
    def validator(text):
        return len(text) >= min_length
    return validator

# Create validators
short_validator = create_validator(3)
long_validator = create_validator(10)

print(short_validator("hi"))      # Output: False
print(short_validator("hello"))   # Output: True
print(long_validator("hello"))    # Output: False
print(long_validator("hello world")) # Output: True
```

### Practical Higher Order Function Examples

```python
# 1. Function composition
def compose(f, g):
    """Compose two functions: f(g(x))"""
    return lambda x: f(g(x))

# Example usage
add_one = lambda x: x + 1
square = lambda x: x ** 2

# Compose: square(add_one(x))
square_after_add_one = compose(square, add_one)
print(square_after_add_one(3))  # Output: 16 (3+1=4, 4²=16)

# 2. Function that creates filters
def create_filter(predicate):
    """Create a filter function"""
    def filter_func(items):
        return [item for item in items if predicate(item)]
    return filter_func

# Create different filters
is_positive = create_filter(lambda x: x > 0)
is_even = create_filter(lambda x: x % 2 == 0)
is_long = create_filter(lambda x: len(x) > 3)

numbers = [-2, -1, 0, 1, 2, 3, 4]
words = ["cat", "dog", "elephant", "bird"]

print(is_positive(numbers))  # Output: [1, 2, 3, 4]
print(is_even(numbers))     # Output: [-2, 0, 2, 4]
print(is_long(words))       # Output: ['elephant']
```

---

## Built-in Functional Tools

### Map Function

**What it does**: Applies a function to every item in an iterable.

**Simple explanation**: Like having a factory assembly line - you put items in, apply the same operation to each, and get transformed items out.

```python
# Basic syntax: map(function, iterable)

# Example 1: Square all numbers
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x ** 2, numbers))
print(squared)  # Output: [1, 4, 9, 16, 25]

# Example 2: Convert to uppercase
names = ["alice", "bob", "charlie"]
upper_names = list(map(str.upper, names))
print(upper_names)  # Output: ['ALICE', 'BOB', 'CHARLIE']

# Example 3: Multiple iterables
list1 = [1, 2, 3]
list2 = [10, 20, 30]
sums = list(map(lambda x, y: x + y, list1, list2))
print(sums)  # Output: [11, 22, 33]

# Example 4: Working with strings
words = ["hello", "world", "python"]
lengths = list(map(len, words))
print(lengths)  # Output: [5, 5, 6]
```

### Filter Function

**What it does**: Keeps only items that meet a condition.

**Simple explanation**: Like a sieve - you pour items through, and only the ones that pass the test come out.

```python
# Basic syntax: filter(function, iterable)

# Example 1: Keep only even numbers
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # Output: [2, 4, 6, 8, 10]

# Example 2: Keep only positive numbers
mixed_numbers = [-5, -2, 0, 3, 7, -1, 4]
positive_numbers = list(filter(lambda x: x > 0, mixed_numbers))
print(positive_numbers)  # Output: [3, 7, 4]

# Example 3: Keep only long words
words = ["cat", "elephant", "dog", "butterfly", "ant"]
long_words = list(filter(lambda x: len(x) > 3, words))
print(long_words)  # Output: ['elephant', 'butterfly']

# Example 4: Keep only non-empty strings
texts = ["hello", "", "world", "", "python"]
non_empty = list(filter(lambda x: x != "", texts))
print(non_empty)  # Output: ['hello', 'world', 'python']

# Example 5: Using built-in functions
numbers = [0, 1, 2, 3, 4, 5]
truthy_numbers = list(filter(None, numbers))  # Removes 0, None, False
print(truthy_numbers)  # Output: [1, 2, 3, 4, 5]
```

### Reduce Function

**What it does**: Applies a function cumulatively to items, reducing them to a single value.

**Simple explanation**: Like folding a piece of paper repeatedly - you start with many items and end up with one result.

```python
from functools import reduce

# Basic syntax: reduce(function, iterable, initial)

# Example 1: Sum all numbers
numbers = [1, 2, 3, 4, 5]
total = reduce(lambda x, y: x + y, numbers)
print(total)  # Output: 15

# Example 2: Find maximum number
numbers = [3, 7, 2, 9, 1, 5]
maximum = reduce(lambda x, y: x if x > y else y, numbers)
print(maximum)  # Output: 9

# Example 3: Multiply all numbers
numbers = [2, 3, 4]
product = reduce(lambda x, y: x * y, numbers)
print(product)  # Output: 24

# Example 4: Concatenate strings
words = ["Hello", " ", "World", "!"]
sentence = reduce(lambda x, y: x + y, words)
print(sentence)  # Output: Hello World!

# Example 5: With initial value
numbers = [1, 2, 3, 4]
sum_with_initial = reduce(lambda x, y: x + y, numbers, 10)
print(sum_with_initial)  # Output: 20 (10 + 1 + 2 + 3 + 4)

# Example 6: Count occurrences
words = ["apple", "banana", "apple", "cherry", "banana", "apple"]
word_count = reduce(lambda acc, word: {**acc, word: acc.get(word, 0) + 1}, words, {})
print(word_count)  # Output: {'apple': 3, 'banana': 2, 'cherry': 1}
```

### Zip Function

**What it does**: Combines multiple iterables into tuples.

**Simple explanation**: Like zipping up a jacket - you align the teeth (items) from both sides and pull them together.

```python
# Basic syntax: zip(iterable1, iterable2, ...)

# Example 1: Basic zipping
names = ["Alice", "Bob", "Charlie"]
ages = [25, 30, 35]
zipped = list(zip(names, ages))
print(zipped)  # Output: [('Alice', 25), ('Bob', 30), ('Charlie', 35)]

# Example 2: Three lists
names = ["Alice", "Bob", "Charlie"]
ages = [25, 30, 35]
cities = ["New York", "London", "Tokyo"]
zipped = list(zip(names, ages, cities))
print(zipped)  # Output: [('Alice', 25, 'New York'), ('Bob', 30, 'London'), ('Charlie', 35, 'Tokyo')]

# Example 3: Different lengths (stops at shortest)
list1 = [1, 2, 3, 4, 5]
list2 = ["a", "b", "c"]
zipped = list(zip(list1, list2))
print(zipped)  # Output: [(1, 'a'), (2, 'b'), (3, 'c')]

# Example 4: Unzipping (reverse operation)
pairs = [('Alice', 25), ('Bob', 30), ('Charlie', 35)]
names, ages = zip(*pairs)
print(names)  # Output: ('Alice', 'Bob', 'Charlie')
print(ages)   # Output: (25, 30, 35)

# Example 5: Creating dictionaries
names = ["Alice", "Bob", "Charlie"]
ages = [25, 30, 35]
person_dict = dict(zip(names, ages))
print(person_dict)  # Output: {'Alice': 25, 'Bob': 30, 'Charlie': 35}

# Example 6: Transposing a matrix
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
transposed = list(zip(*matrix))
print(transposed)  # Output: [(1, 4, 7), (2, 5, 8), (3, 6, 9)]
```

---

## Advanced Concepts

### Function Composition

**What it is**: Combining multiple functions to create a new function.

```python
# Simple composition
def compose(f, g):
    """Compose f and g: f(g(x))"""
    return lambda x: f(g(x))

# Example
add_one = lambda x: x + 1
square = lambda x: x ** 2

# Compose: square(add_one(x))
square_after_add_one = compose(square, add_one)
print(square_after_add_one(3))  # Output: 16

# Multiple composition
def compose_many(*functions):
    """Compose multiple functions"""
    def composed(x):
        result = x
        for func in reversed(functions):
            result = func(result)
        return result
    return composed

# Example
add_two = lambda x: x + 2
multiply_by_three = lambda x: x * 3

# Compose: multiply_by_three(add_two(square(x)))
complex_func = compose_many(multiply_by_three, add_two, square)
print(complex_func(2))  # Output: 18 ((2² + 2) * 3 = 18)
```

### Partial Functions

**What it is**: Creating new functions with some arguments pre-filled.

```python
from functools import partial

# Example 1: Basic partial
def multiply(x, y):
    return x * y

# Create a function that always multiplies by 2
double = partial(multiply, 2)
print(double(5))  # Output: 10

# Example 2: Multiple arguments
def greet(greeting, name, punctuation):
    return f"{greeting}, {name}{punctuation}"

# Create different greeting functions
say_hello = partial(greet, "Hello", punctuation="!")
say_goodbye = partial(greet, "Goodbye", punctuation=".")

print(say_hello("Alice"))    # Output: Hello, Alice!
print(say_goodbye("Bob"))    # Output: Goodbye, Bob.

# Example 3: With map
numbers = [1, 2, 3, 4, 5]
multiply_by_three = partial(multiply, 3)
tripled = list(map(multiply_by_three, numbers))
print(tripled)  # Output: [3, 6, 9, 12, 15]
```

### Currying

**What it is**: Converting a function that takes multiple arguments into a series of functions that each take one argument.

```python
# Regular function
def add_three_numbers(x, y, z):
    return x + y + z

# Curried version
def curried_add(x):
    def inner(y):
        def innermost(z):
            return x + y + z
        return innermost
    return inner

# Usage
result = curried_add(1)(2)(3)
print(result)  # Output: 6

# More practical currying
def curry(func):
    """Convert a function to curried form"""
    def curried(*args):
        if len(args) >= func.__code__.co_argcount:
            return func(*args)
        return lambda *more_args: curried(*(args + more_args))
    return curried

# Example
@curry
def multiply_three(x, y, z):
    return x * y * z

# Can be called in different ways
print(multiply_three(2)(3)(4))      # Output: 24
print(multiply_three(2, 3)(4))      # Output: 24
print(multiply_three(2, 3, 4))      # Output: 24
```

---

## Decorators

### What are Decorators? (Simple Explanation)

**Decorators** are functions that modify or enhance other functions without changing their code.

**Real-world analogy**:
- Like **wrapping a gift** - the gift (function) stays the same, but you add a wrapper (decorator) around it
- Like **adding features to a car** - the car works the same, but now it has GPS, heated seats, etc.

### Basic Decorator Syntax

```python
# Decorator function
def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

# Using the decorator
@my_decorator
def say_hello():
    print("Hello!")

# This is equivalent to:
# say_hello = my_decorator(say_hello)

say_hello()
# Output:
# Something is happening before the function is called.
# Hello!
# Something is happening after the function is called.
```

### Decorator Examples

```python
# 1. Timing decorator
import time

def timing_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time:.4f} seconds")
        return result
    return wrapper

@timing_decorator
def slow_function():
    time.sleep(1)
    return "Done!"

result = slow_function()
# Output: slow_function took 1.0000 seconds

# 2. Logging decorator
def log_calls(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args: {args}, kwargs: {kwargs}")
        result = func(*args, **kwargs)
        print(f"{func.__name__} returned: {result}")
        return result
    return wrapper

@log_calls
def add_numbers(x, y):
    return x + y

result = add_numbers(3, 5)
# Output:
# Calling add_numbers with args: (3, 5), kwargs: {}
# add_numbers returned: 8

# 3. Retry decorator
def retry(max_attempts=3):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        raise e
                    print(f"Attempt {attempt + 1} failed: {e}. Retrying...")
            return None
        return wrapper
    return decorator

@retry(max_attempts=3)
def unreliable_function():
    import random
    if random.random() < 0.7:  # 70% chance of failure
        raise Exception("Random failure!")
    return "Success!"

# 4. Validation decorator
def validate_types(**expected_types):
    def decorator(func):
        def wrapper(*args, **kwargs):
            # Get function parameter names
            import inspect
            sig = inspect.signature(func)
            bound_args = sig.bind(*args, **kwargs)
            bound_args.apply_defaults()
            
            # Validate types
            for param_name, expected_type in expected_types.items():
                if param_name in bound_args.arguments:
                    value = bound_args.arguments[param_name]
                    if not isinstance(value, expected_type):
                        raise TypeError(f"{param_name} must be {expected_type.__name__}, got {type(value).__name__}")
            
            return func(*args, **kwargs)
        return wrapper
    return decorator

@validate_types(x=int, y=int)
def multiply(x, y):
    return x * y

print(multiply(3, 5))  # Output: 15
# print(multiply(3, "5"))  # Would raise TypeError
```

### Class Decorators

```python
# Class-based decorator
class CountCalls:
    def __init__(self, func):
        self.func = func
        self.count = 0
    
    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"Call {self.count} of {self.func.__name__}")
        return self.func(*args, **kwargs)

@CountCalls
def greet(name):
    return f"Hello, {name}!"

print(greet("Alice"))  # Output: Call 1 of greet
print(greet("Bob"))    # Output: Call 2 of greet
print(greet("Charlie")) # Output: Call 3 of greet
```

### Decorator with Arguments

```python
# Decorator that takes arguments
def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(times=3)
def say_hello():
    print("Hello!")

say_hello()
# Output:
# Hello!
# Hello!
# Hello!
```

---

## Function Arguments (*args, **kwargs)

### *args (Variable Positional Arguments)

**What it is**: Allows a function to accept any number of positional arguments.

**Simple explanation**: Like a shopping cart that can hold any number of items.

```python
# Basic *args
def sum_all(*args):
    """Sum all the arguments"""
    total = 0
    for num in args:
        total += num
    return total

print(sum_all(1, 2, 3))           # Output: 6
print(sum_all(1, 2, 3, 4, 5))     # Output: 15
print(sum_all())                   # Output: 0

# *args with other parameters
def greet_and_sum(greeting, *names):
    """Greet multiple people and sum their name lengths"""
    total_length = sum(len(name) for name in names)
    return f"{greeting}! Total name length: {total_length}"

print(greet_and_sum("Hello", "Alice", "Bob", "Charlie"))
# Output: Hello! Total name length: 13

# Unpacking with *args
def multiply_all(*numbers):
    """Multiply all numbers"""
    result = 1
    for num in numbers:
        result *= num
    return result

numbers = [2, 3, 4]
print(multiply_all(*numbers))  # Output: 24 (unpacks the list)

# Mixing *args with regular parameters
def create_sentence(subject, verb, *objects):
    """Create a sentence from parts"""
    return f"{subject} {verb} {' '.join(objects)}"

print(create_sentence("I", "like", "pizza", "and", "pasta"))
# Output: I like pizza and pasta
```

### **kwargs (Variable Keyword Arguments)

**What it is**: Allows a function to accept any number of keyword arguments.

**Simple explanation**: Like a form that can have any number of optional fields.

```python
# Basic **kwargs
def print_info(**kwargs):
    """Print all keyword arguments"""
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="Alice", age=25, city="New York")
# Output:
# name: Alice
# age: 25
# city: New York

# **kwargs with other parameters
def create_profile(name, email, **details):
    """Create a user profile"""
    profile = {
        "name": name,
        "email": email,
        **details  # Unpack additional details
    }
    return profile

profile = create_profile("Alice", "alice@email.com", 
                        age=25, city="New York", job="Developer")
print(profile)
# Output: {'name': 'Alice', 'email': 'alice@email.com', 'age': 25, 'city': 'New York', 'job': 'Developer'}

# Unpacking dictionaries
def calculate_total(**prices):
    """Calculate total from prices"""
    return sum(prices.values())

menu = {"pizza": 15, "burger": 12, "drink": 3}
total = calculate_total(**menu)  # Unpack the dictionary
print(total)  # Output: 30
```

### Combining *args and **kwargs

```python
# Both *args and **kwargs
def flexible_function(*args, **kwargs):
    """Function that accepts any arguments"""
    print("Positional arguments:", args)
    print("Keyword arguments:", kwargs)

flexible_function(1, 2, 3, name="Alice", age=25)
# Output:
# Positional arguments: (1, 2, 3)
# Keyword arguments: {'name': 'Alice', 'age': 25}

# Practical example
def log_function_call(func):
    """Decorator that logs function calls"""
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with:")
        print(f"  args: {args}")
        print(f"  kwargs: {kwargs}")
        result = func(*args, **kwargs)
        print(f"  result: {result}")
        return result
    return wrapper

@log_function_call
def add_numbers(x, y, multiplier=1):
    return (x + y) * multiplier

add_numbers(3, 5, multiplier=2)
# Output:
# Calling add_numbers with:
#   args: (3, 5)
#   kwargs: {'multiplier': 2}
#   result: 16
```

### Advanced Usage Examples

```python
# 1. Function that forwards arguments
def forward_to_other_function(*args, **kwargs):
    """Forward arguments to another function"""
    return other_function(*args, **kwargs)

def other_function(x, y, z=0):
    return x + y + z

print(forward_to_other_function(1, 2, z=3))  # Output: 6

# 2. Partial function application
def partial_apply(func, *fixed_args, **fixed_kwargs):
    """Create a partial function with some arguments fixed"""
    def wrapper(*args, **kwargs):
        return func(*fixed_args, *args, **fixed_kwargs, **kwargs)
    return wrapper

def multiply(x, y, z):
    return x * y * z

multiply_by_two = partial_apply(multiply, 2)
print(multiply_by_two(3, 4))  # Output: 24

# 3. Function composition with arguments
def compose_with_args(*functions):
    """Compose functions that might have different signatures"""
    def composed(*args, **kwargs):
        result = functions[0](*args, **kwargs)
        for func in functions[1:]:
            result = func(result)
        return result
    return composed

add_one = lambda x: x + 1
square = lambda x: x ** 2
double = lambda x: x * 2

composed_func = compose_with_args(add_one, square, double)
print(composed_func(3))  # Output: 32 ((3+1)² * 2 = 32)
```

---

## Practical Examples

### Data Processing Pipeline

```python
# Functional approach to data processing
def process_student_data(students):
    """Process student data using functional programming"""
    
    # Filter students with grade >= 80
    high_achievers = filter(lambda s: s['grade'] >= 80, students)
    
    # Extract names
    names = map(lambda s: s['name'], high_achievers)
    
    # Convert to uppercase
    upper_names = map(str.upper, names)
    
    # Join with commas
    result = ', '.join(upper_names)
    
    return result

students = [
    {'name': 'Alice', 'grade': 85},
    {'name': 'Bob', 'grade': 92},
    {'name': 'Charlie', 'grade': 78},
    {'name': 'Diana', 'grade': 88}
]

print(process_student_data(students))
# Output: ALICE, BOB, DIANA
```

### Configuration Management

```python
# Functional configuration system
def create_config(**defaults):
    """Create a configuration function"""
    def config(**overrides):
        return {**defaults, **overrides}
    return config

# Create different configs
database_config = create_config(
    host='localhost',
    port=5432,
    user='admin',
    password='secret'
)

api_config = create_config(
    base_url='https://api.example.com',
    timeout=30,
    retries=3
)

# Use configs
db_settings = database_config(port=3306, user='root')
api_settings = api_config(timeout=60)

print(db_settings)   # Output: {'host': 'localhost', 'port': 3306, 'user': 'root', 'password': 'secret'}
print(api_settings)  # Output: {'base_url': 'https://api.example.com', 'timeout': 60, 'retries': 3}
```

### Event System

```python
# Functional event system
class EventSystem:
    def __init__(self):
        self.handlers = {}
    
    def on(self, event_name, handler):
        """Register an event handler"""
        if event_name not in self.handlers:
            self.handlers[event_name] = []
        self.handlers[event_name].append(handler)
        return self
    
    def emit(self, event_name, *args, **kwargs):
        """Emit an event to all handlers"""
        if event_name in self.handlers:
            for handler in self.handlers[event_name]:
                handler(*args, **kwargs)
        return self

# Usage
events = EventSystem()

# Register handlers
events.on('user_login', lambda user: print(f"User {user} logged in"))
events.on('user_login', lambda user: print(f"Welcome back, {user}!"))

events.on('user_logout', lambda user: print(f"User {user} logged out"))

# Emit events
events.emit('user_login', 'Alice')
# Output:
# User Alice logged in
# Welcome back, Alice!

events.emit('user_logout', 'Alice')
# Output: User Alice logged out
```

---

## Best Practices

### 1. Keep Functions Pure

```python
# Good: Pure function
def add_numbers(x, y):
    return x + y

# Bad: Function with side effects
total = 0
def add_to_total(x):
    global total
    total += x
    return total
```

### 2. Use Descriptive Names

```python
# Good: Descriptive names
def calculate_total_price(items):
    return sum(item['price'] for item in items)

# Bad: Unclear names
def calc(items):
    return sum(i['p'] for i in items)
```

### 3. Prefer Composition Over Complex Logic

```python
# Good: Composed functions
def process_data(data):
    return format_output(transform_data(filter_data(data)))

# Bad: One complex function
def process_data(data):
    # 50 lines of complex logic
    pass
```

### 4. Use Type Hints

```python
from typing import List, Callable, Any

def apply_function(func: Callable[[int], int], numbers: List[int]) -> List[int]:
    return [func(num) for num in numbers]

def add_one(x: int) -> int:
    return x + 1

result = apply_function(add_one, [1, 2, 3, 4, 5])
print(result)  # Output: [2, 3, 4, 5, 6]
```

### 5. Handle Edge Cases

```python
def safe_divide(x: float, y: float) -> float:
    """Safely divide two numbers"""
    if y == 0:
        raise ValueError("Cannot divide by zero")
    return x / y

def process_numbers(numbers: List[int]) -> List[int]:
    """Process numbers, handling empty list"""
    if not numbers:
        return []
    return [num * 2 for num in numbers]
```

---

## Exercises

### Exercise 1: Basic Lambda Functions
```python
# Create lambda functions for:
# 1. Check if a number is even
# 2. Convert temperature from Celsius to Fahrenheit
# 3. Extract the first character of a string

# Solutions:
is_even = lambda x: x % 2 == 0
celsius_to_fahrenheit = lambda c: (c * 9/5) + 32
first_char = lambda s: s[0] if s else ""

print(is_even(4))                    # Output: True
print(celsius_to_fahrenheit(25))      # Output: 77.0
print(first_char("Hello"))           # Output: H
```

### Exercise 2: Map and Filter
```python
# Given a list of numbers, create a new list containing only the squares of even numbers
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Solution:
even_squares = list(map(lambda x: x**2, filter(lambda x: x % 2 == 0, numbers)))
print(even_squares)  # Output: [4, 16, 36, 64, 100]
```

### Exercise 3: Reduce Function
```python
# Use reduce to find the longest string in a list
from functools import reduce

words = ["apple", "banana", "cherry", "date"]

# Solution:
longest = reduce(lambda x, y: x if len(x) > len(y) else y, words)
print(longest)  # Output: banana
```

### Exercise 4: Decorator
```python
# Create a decorator that measures and prints the execution time of a function
import time

def timing_decorator(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.4f} seconds")
        return result
    return wrapper

@timing_decorator
def slow_function():
    time.sleep(1)
    return "Done!"

slow_function()  # Output: slow_function took 1.0000 seconds
```

### Exercise 5: Higher Order Function
```python
# Create a function that takes a list of functions and applies them in sequence
def compose_functions(*functions):
    def composed(x):
        result = x
        for func in functions:
            result = func(result)
        return result
    return composed

# Test
add_one = lambda x: x + 1
square = lambda x: x ** 2
double = lambda x: x * 2

composed = compose_functions(add_one, square, double)
print(composed(3))  # Output: 32 ((3+1)² * 2 = 32)
```

---

## Summary

### Key Concepts Covered:

1. **Functional Programming Principles**
   - Pure functions
   - Immutability
   - Function composition

2. **Lambda Functions**
   - Anonymous functions
   - Quick, one-liner operations
   - Use with map, filter, reduce

3. **Higher Order Functions**
   - Functions that take/return other functions
   - Function composition
   - Partial application

4. **Built-in Tools**
   - `map()` - transform each item
   - `filter()` - keep items that meet condition
   - `reduce()` - combine items into single result
   - `zip()` - combine multiple iterables

5. **Advanced Features**
   - Decorators for function enhancement
   - `*args` and `**kwargs` for flexible arguments
   - Partial functions and currying

### When to Use Functional Programming:

**Good for**:
- Data transformation pipelines
- Mathematical computations
- Event handling systems
- Configuration management
- Small, focused operations

**Consider alternatives when**:
- Complex state management needed
- Performance is critical
- Working with object-oriented codebases
- Team prefers imperative style

### Next Steps:
1. Practice with the exercises
2. Apply functional concepts to real projects
3. Learn about functional libraries (functools, itertools)
4. Explore functional programming in other languages

---

*Remember: Functional programming is a powerful tool in your programming toolkit. Use it where it makes sense, and don't force it where it doesn't!*
